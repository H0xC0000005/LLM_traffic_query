# add this small helper near your other helpers
def _clamp(x, lo, hi):  # >>> NEW
    return max(lo, min(hi, x))

def draw_sumo_style_panels(
    snapshot: Dict[str, Any],
    validate: bool = True,
    figsize: Tuple[float,float] = (16,7),
    lane_height: float = 1.3,
    lane_vpad: float = 0.4,
    font_size: int = 10,
    vehicle_height_frac: float = 0.75,
    save_path: Optional[str] = None,
    violations_out: Optional[str] = None,
    print_violations: bool = True,
    # ---------------- label controls ----------------
    label_mode: str = "stagger",            # >>> NEW: "stagger" or "center"
    label_jitter_frac: float = 0.15,        # >>> NEW: vertical jitter as fraction of vehicle height
    label_x_jitter_m: float = 0.2,          # >>> NEW: small horizontal jitter in meters
    label_bbox: bool = True                 # >>> NEW: white background box behind text
) -> List[Dict[str, Any]]:
    ...
    phase = meta.get("phase", "sync")
    window_m = float(meta.get("window_m", 200.0))
    base_seed = int(meta.get("seed", 0))    # >>> NEW: make jitter deterministic if seed present

    ...
    lane_centers_y = {}
    lane_bounds = {}  # >>> NEW: store (y0, y1) per lane for clamping
    for lid in lane_ids:
        base -= lane_height
        y0 = base
        ...
        lane_centers_y[lid] = y0 + lane_height/2.0
        lane_bounds[lid] = (y0, y0 + lane_height)   # >>> NEW
        base -= lane_vpad

    # Prepare collections for validation (include ego!)
    per_lane: Dict[int, List[Dict[str, Any]]] = {lid: [] for lid in lane_ids}
    vt_defaults = VALIDATION_CONSTANTS["vehicle_types"]
    gap_scale = VALIDATION_CONSTANTS["phase_params"].get(phase, {"gap_scale":1.0})["gap_scale"]

    # --------- label utilities (NEW) ----------
    # cycle of offsets (fractions of vehicle height) to stagger labels per lane
    _STAGGER = [0.0, +0.28, -0.28, +0.48, -0.48]     # >>> NEW
    lane_label_idx = {lid: 0 for lid in lane_ids}    # >>> NEW

    def _label_xy(lane_id: int, s: float, y_center: float, veh_h: float, vid: str) -> Tuple[float,float]:
        """Compute label (x,y) using stagger + jitter and clamp inside the lane band."""  # >>> NEW
        if label_mode == "center":
            y = y_center
            x = s
        else:
            k = lane_label_idx[lane_id] % len(_STAGGER)
            lane_label_idx[lane_id] += 1
            y_off = _STAGGER[k] * veh_h

            # deterministic jitter
            jseed = (base_seed * 73856093) ^ (hash(vid) & 0xFFFFFFFF) ^ (lane_id * 19349663)
            rng = random.Random(jseed)
            y_off += (rng.uniform(-1.0, 1.0) * label_jitter_frac * veh_h)
            x_off = rng.uniform(-1.0, 1.0) * label_x_jitter_m

            y = y_center + y_off
            x = s + x_off

        # clamp label Y to lane band with a small margin
        y0, y1 = lane_bounds[lane_id]
        margin = 0.10 * lane_height
        y = _clamp(y, y0 + margin, y1 - margin)
        return x, y

    txt_bbox = dict(facecolor="white", alpha=0.7, edgecolor="none", boxstyle="round,pad=0.2") if label_bbox else None  # >>> NEW

    # Draw ego with speed (keep centered or give it stagger as well if you want)
    ego = snapshot["ego"]
    ...
    ax.add_patch(ego_rect)
    ex, ey = _label_xy(ego_lane, 0.0, ego_y, ego_h, "ego")  # >>> NEW (use same label logic)
    ax.text(ex, ey, f"EGO {int(round(ego_speed))} km/h",
            ha="center", va="center", fontsize=font_size, color="black",
            zorder=4, bbox=txt_bbox)                          # >>> CHANGED: bbox + new position
    per_lane[ego_lane].append({...})

    # Draw other vehicles
    legend_types: Set[str] = set()
    for v in vehicles:
        lane_id, s = v["coord"]
        y = lane_centers_y[lane_id]
        length = float(v.get("length_m", vt_defaults.get(v["type"], {"length_m":4.5})["length_m"]))
        height = lane_height * vehicle_height_frac
        color = TYPE_COLORS.get(v["type"], "#999999")
        rect = Rectangle((s - length/2.0, y - height/2.0), length, height,
                         facecolor=color, edgecolor="black", linewidth=1.5, zorder=3)
        ax.add_patch(rect)

        # >>> NEW: compute label position (stagger + jitter + clamp) and draw with background
        lx, ly = _label_xy(lane_id, float(s), y, height, v.get("id", f"{lane_id}_{s}"))
        ax.text(lx, ly, f"{int(round(v['speed_kmh']))} km/h",
                ha="center", va="center", fontsize=font_size, color="black",
                zorder=4, bbox=txt_bbox)

        per_lane[lane_id].append({...})
        legend_types.add(v["type"])
